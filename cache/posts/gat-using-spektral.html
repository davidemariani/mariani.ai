<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the past few months, during a job interview, I have been given a take home assessment about graph machine learning.<br>
The dataset I had to work on was the <a href="https://paperswithcode.com/dataset/ppi" target="_blank">PPI dataset</a> (with few changes from its original version).<br>
Being a Python and Tensorflow user, I decided to tackle it using the framework <a href="https://graphneural.network/" target="_blank">Spektral</a><a href="#fn1"><sup>1</sup></a> by <a href="https://danielegrattarola.github.io/" target="_blank">Daniele Grattarola</a>, and since apparently there are not many examples of similar applications on PPI out there, I though of sharing my code.
<!-- TEASER_END --></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3><strong>Table of contents:</strong></h3><ol>
<li><a href="#task-desc">Description of the task</a></li>
<li><a href="#approach">My Approach</a></li>
<li><a href="#modules">Required modules</a></li>
<li><a href="#eda">Quick EDA</a></li>
<li><a href="#txt">Text processing and features extraction</a></li>
<li><a href="#spektral-ds">Creating Spektral graph datasets</a></li>
<li><a href="#gat">Implementing the GAT model</a></li>
<li><a href="#train">Training and evaluating the model</a></li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>Description of the task</strong></h2> <a class="anchor" id="task-desc"></a></p>
<p><strong>The dataset</strong><br>
The provided dataset was a modification of a protein-protein interaction dataset described in <a href="https://arxiv.org/abs/1707.04638" target="_blank"><em>Zitnik & Leskovec, 2017</em></a><a href="#fn2"><sup>2</sup></a>, where protein interactions are modelled as graph edges. 
The data consisted of train, test and validation sets, each of which was made of 4 files:</p>
<ul>
<li><code>SET_feats.npy</code>: a numpy matrix where each row is a numerical feature vector corresponding to a graph node</li>
<li><code>SET_labels.npy</code>: a numpy matrix where each row is a K-hot vector of labels for each graph node</li>
<li><code>SET_graph_ids.npy</code>: a numpy array where each element value indicates the graph ID to which the given node belongs.</li>
<li><code>SET_graph.json</code> : a json file containing information about all graphs in this data set (with fields regarding <code>nodes</code> and <code>links</code>) </li>
</ul>
<p><strong>Changes to the original dataset</strong></p>
<ul>
<li>The <code>nodes</code> field in <code>SET_graph.json</code> contains a list of dictionaries corresponding to each node. Each node has a <code>text</code> field, where arbitrary text data extracted from StackOverflow has been appended. </li>
<li>Under the <code>links</code> field, a list of <code>source</code> and <code>target</code> pairs representing graph edges has been added.  </li>
</ul>
<p><strong>The task</strong><br>
The task involved the implementation of <em>"a machine learning algorithm to train on this dataset"</em>. Since the text appended to each node information does not have predictive abilities for the graph, it was recommended not to try generating good quality predictions, but to focus on researching the most appropriate approach for this type of dataset, where graph node features contain text.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>My approach</strong></h2> <a class="anchor" id="approach"></a></p>
<p>After a first look at the dataset, I concluded that I was dealing with <a href=" https://en.wikipedia.org/wiki/Multi-label_classification" target="_blank"><em><strong>multi-label classification</strong></em></a>, and started doing some research on similar tasks. I found that an <a href="https://mariani.ai/posts/a-quick-introduction-to-graph-neural-networks/#transductive-inductive" target="_blank"><em>inductive approach</em></a> could be used; specifically, the paper <a href="https://arxiv.org/pdf/1710.10903.pdf" target="_blank"><em>Graph Attention Networks</em></a><a href="#fn3"><sup>3</sup></a> describes how the attention mechanism is performed across nodes and edges outperforming the <a href="https://arxiv.org/pdf/1706.02216.pdf" target="_blank"><em>GraphSAGE approach</em></a><a href="#fn4"><sup>4</sup></a> on the PPI dataset (the original one, without any addition).<br>
Hence, this is the architecture I have chosen for this exercise. About the text features, since they were not giving any additional predictive power I just thought of processing the data with simple <a href="https://en.wikipedia.org/wiki/Bag-of-words_model" target="_blank">Bag of Words</a> (BOW) approach and appending the extracted features to the node vectors.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>Required modules</strong></h2> <a class="anchor" id="modules"></a></p>
<p>I work mainly in Python, so these are the main libraries that I have been using for this exercise:</p>
<ul>
<li><strong>networkx</strong> for some data exploration and for creating the ajaciency matrices</li>
<li><strong>tensorflow</strong> as a main deep learning framework</li>
<li><strong>nltk</strong> for text processing(in particular, <code>nltk.tokenize.word_tokenize</code> for tokenization, <code>nltk.stem.snowball.SnowballStemmer</code> for stemming and <code>nltk.corpus.stopwords</code> for a reliable list of stop words to remove during preprocessing)</li>
<li><strong>scikit learn</strong> (mainly for using the <code>sklearn.feature_extraction.text.CountVectorizer</code>)</li>
<li><strong>spektral</strong> as I mentioned in the intro</li>
<li>and obviously <strong>numpy</strong></li>
</ul>
<p>You can have a look at the main modules imported from tensorflow and spektral below:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras.callbacks</span> <span class="kn">import</span> <span class="n">EarlyStopping</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.layers</span> <span class="kn">import</span> <span class="n">Input</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.losses</span> <span class="kn">import</span> <span class="n">BinaryCrossentropy</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.models</span> <span class="kn">import</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.optimizers</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">tensorflow.random</span> <span class="kn">import</span> <span class="n">set_seed</span>

<span class="kn">from</span> <span class="nn">spektral.data</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">Graph</span>
<span class="kn">from</span> <span class="nn">spektral.data</span> <span class="kn">import</span> <span class="n">DisjointLoader</span>
<span class="kn">from</span> <span class="nn">spektral.layers</span> <span class="kn">import</span> <span class="n">GATConv</span>
<span class="kn">from</span> <span class="nn">spektral.transforms</span> <span class="kn">import</span> <span class="n">LayerPreprocess</span>

<span class="kn">from</span> <span class="nn">tensorflow_addons.metrics</span> <span class="kn">import</span> <span class="n">F1Score</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>Quick EDA</strong></h2> <a class="anchor" id="eda"></a></p>
<p>Here's the script used for loading the datasets provided, and some quick exploration of the data available.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#looading training data</span>
<span class="n">train_graph_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/train_graph_id.npy&#39;</span><span class="p">)</span>
<span class="n">train_feats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/train_feats.npy&#39;</span><span class="p">)</span>
<span class="n">train_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/train_labels.npy&#39;</span><span class="p">)</span>

<span class="c1">#loading validation data</span>
<span class="n">valid_graph_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/valid_graph_id.npy&#39;</span><span class="p">)</span>
<span class="n">valid_feats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/valid_feats.npy&#39;</span><span class="p">)</span>
<span class="n">valid_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/valid_labels.npy&#39;</span><span class="p">)</span>

<span class="c1">#loading test data</span>
<span class="n">test_graph_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/test_graph_id.npy&#39;</span><span class="p">)</span>
<span class="n">test_feats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/test_feats.npy&#39;</span><span class="p">)</span>
<span class="n">test_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;data/test_labels.npy&#39;</span><span class="p">)</span>

<span class="c1">#loading graph info</span>
<span class="k">def</span> <span class="nf">load_json</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">output</span>

<span class="n">train_graph</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="s1">&#39;data/train_graph.json&#39;</span><span class="p">)</span>
<span class="n">valid_graph</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="s1">&#39;data/valid_graph.json&#39;</span><span class="p">)</span>
<span class="n">test_graph</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="s1">&#39;data/test_graph.json&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The dataset is split into train, validation and test set; each of them contains the following:</p>
<ul>
<li>44906 nodes over 20 graphs in the training set</li>
<li>6514 nodes over 2 graphs in the validation set</li>
<li>5524 nodes over 2 graphs in the test set  </li>
</ul>
<p>Each node is represented by a 50-dimensional feature vector.<br>
The labels have a shape like the one shown below.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[6]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>array([1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1,
       0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
       0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0,
       0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
       0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], dtype=int64)</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Each element of <code>['nodes']</code> is a dictionary containing <code>'id'</code> and <code>'text'</code> for a the corresponding <strong>node</strong>, and this is an example of what the text added to the nodes looks like:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_graph</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[12]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>{&#39;id&#39;: 0,
 &#39;text&#39;: &#39;How do I fill a DataSet or a DataTable from a LINQ query resultset ?&#39;}</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On the other hand, each element of <code>['links']</code> is a dictionary containing <code>'source'</code> and <code>'target'</code> information of an <strong>edge</strong>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[14]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_graph</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[14]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>{&#39;source&#39;: 0, &#39;target&#39;: 372}</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>Text processing and features extraction</strong></h2> <a class="anchor" id="txt"></a></p>
<p>Since predictive results were not the point of the exercise as the texts associated with each node were basically thrown randomly, I opted for a very quick and easy approach: I concatenated the features coming from the text data with the provided PPI node features. 
For doing that, I have performed the following steps:</p>
<ul>
<li>Cleaning the text data removing punctuation, stop words and some symbol characters, and performing stemming</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[18]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#replace symbols with a space</span>
<span class="n">re_replace_by_space</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[/()</span><span class="si">{}</span><span class="s1">\[\]\|@,;]&#39;</span><span class="p">)</span> 

<span class="c1">#symbols to remove</span>
<span class="n">re_remove</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[^0-9a-z #+_]&#39;</span><span class="p">)</span> 

<span class="c1">#stopwords</span>
<span class="n">stop_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">))</span>

<span class="n">stemmer</span> <span class="o">=</span> <span class="n">SnowballStemmer</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">text_prepare</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        text: a string</span>
<span class="sd">        return: modified initial string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="c1"># lowercase text</span>
    
    <span class="c1">#perform replace and delete operations</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re_replace_by_space</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re_remove</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    
    <span class="c1">#remove stopwords and apply stemmer</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> \ 
                     <span class="k">if</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stop_words</span><span class="p">])</span> 
    
    <span class="k">return</span> <span class="n">text</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Performing BOW with <code>CountVectorizer</code></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[19]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#CountVectorizer - fitting and performing transform on training data</span>
<span class="n">train_corpus</span> <span class="o">=</span> <span class="p">[</span><span class="n">text_prepare</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">train_graph</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]]</span>

<span class="n">ctv</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">word_tokenize</span><span class="p">,</span> <span class="n">token_pattern</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">train_ctv_feats</span> <span class="o">=</span> <span class="n">ctv</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">train_corpus</span><span class="p">)</span>

<span class="c1"># transforming valid data</span>
<span class="n">valid_corpus</span> <span class="o">=</span> <span class="p">[</span><span class="n">text_prepare</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">valid_graph</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]]</span>
<span class="n">valid_ctv_feats</span> <span class="o">=</span> <span class="n">ctv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">valid_corpus</span><span class="p">)</span>

<span class="c1"># transforming test data</span>
<span class="n">test_corpus</span> <span class="o">=</span> <span class="p">[</span><span class="n">text_prepare</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">test_graph</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]]</span>
<span class="n">test_ctv_feats</span> <span class="o">=</span> <span class="n">ctv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">test_corpus</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Performing dimensionality reduction step using <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" target="_blank">Singular Value Decomposition</a>. This step is done to avoid concatenating a matrix that would result too sparse leading the model to overfit</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[21]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#perform dimensionality reduction with latent semantics analysis</span>
<span class="n">svd</span> <span class="o">=</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">TruncatedSVD</span><span class="p">(</span><span class="n">n_components</span> <span class="o">=</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">train_ctv_feats_reduced</span> <span class="o">=</span> <span class="n">svd</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">train_ctv_feats</span><span class="p">)</span>

<span class="c1">#reduce validation and test set with the SVD fit on the training part</span>
<span class="n">valid_ctv_feats_reduced</span> <span class="o">=</span> <span class="n">svd</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">valid_ctv_feats</span><span class="p">)</span>
<span class="n">test_ctv_feats_reduced</span> <span class="o">=</span> <span class="n">svd</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">test_ctv_feats</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Concatenating the provided node feature vectors with the resulting text feature vectors</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[23]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#concatenating provided node feats with the text feats</span>
<span class="n">train_feats_conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">train_feats</span><span class="p">,</span> <span class="n">train_ctv_feats_reduced</span><span class="p">),</span> 
                                  <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">valid_feats_conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">valid_feats</span><span class="p">,</span> <span class="n">valid_ctv_feats_reduced</span><span class="p">),</span> 
                                  <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">test_feats_conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">test_feats</span><span class="p">,</span> <span class="n">test_ctv_feats_reduced</span><span class="p">),</span> 
                                 <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Please note: to avoid forward looking, both <code>CountVectorizer</code> and <code>TruncatedSVD</code> have been fit on training data only, and then used for transforming training, validation and test portion.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>Creating Spektral graph datasets</strong></h2> <a class="anchor" id="spektral-ds"></a></p>
<p>The PPI dataset is <a href = "https://graphneural.network/datasets/" target="_blank"> readily available within Spektral</a>, but since I had to deal with a modified version of it, I thought of taking the chance to learn a bit more about how to create a graph dataset by myself.</p>
<p>I have used the <a href = "https://graphneural.network/creating-dataset/" target = "_blank">`spektral.data.Dataset`</a> class to create three custom datasets: one for training, one for validation and one for testing.<br>
Spektral has three different <a href = "https://graphneural.network/data-modes/" target="_blank">data modes</a> that can be used to model the graph data, depending on use case, scalability and modelling requirements: <em>single mode</em>, <em>disjoint mode</em> and <em>batch mode</em>.<br>
I am not covering them in detail since the original documentation linked above describes them clearly and it is very useful for having a deeper understanding.<br>
I used the <a href="https://graphneural.network/data-modes/#disjoint-mode" target="_blank">**Disjoint Mode**</a>, which is a clever solution for creating a single adjaciency matrix that includes all the graphs in a given set (training, validation or testing) in its diagonal, and to use all of them for training and evaluation sessions.</p>
<p>According with the documentation, the <code>Dataset</code> class essentially needs the following:</p>
<ul>
<li>a <code>read</code> method that is called at every instantiation of the dataset and must return a list of <code>spektral.data.Graph</code></li>
<li>an <code>__init__</code> method that calls both <code>read</code> (and also <code>download</code>, that I am not covering here). </li>
</ul>
<p>To override the dataset initialization, we can call <code>super().__init__()</code> somewhere in your implementation (usually as the last line).</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">myCustomDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The graphs dataset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_info</span><span class="p">,</span> <span class="n">feats</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">graphs_id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attr:</span>
<span class="sd">        - graph_info: a dictionary containing graph information </span>
<span class="sd">                      in the form</span>
<span class="sd">                      {&#39;directed&#39;: bool, </span>
<span class="sd">                      &#39;multigraph&#39;: bool, </span>
<span class="sd">                      &#39;graph&#39;: [], </span>
<span class="sd">                      &#39;nodes&#39;:[{},{}], &#39;links&#39;:[{},{}]}</span>
<span class="sd">        - feats: the feature vectors for each node</span>
<span class="sd">        - labels: the labels for each node</span>
<span class="sd">        - graphs_id: the graph masks, indicating what graph </span>
<span class="sd">                     each node belongs to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">feats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graphs_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graphs_id</span><span class="p">)</span>
        
        <span class="c1">#adding corresponding graph id to the node info</span>
        <span class="k">for</span> <span class="n">n_idx</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_info</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]):</span>
            <span class="n">n</span><span class="p">[</span><span class="s1">&#39;graph_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graphs_id</span><span class="p">[</span><span class="n">n_idx</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_info</span> <span class="o">=</span> <span class="n">graph_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_info</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]])</span>
        
        <span class="c1">#graph to node correspondence dict</span>
        <span class="n">g_to_n_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nodeslab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graphs_id</span><span class="p">):</span>
            <span class="n">g_to_n_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodeslab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graphs_id</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span>    
        <span class="bp">self</span><span class="o">.</span><span class="n">__g_to_n_dict</span> <span class="o">=</span> <span class="n">g_to_n_dict</span>
        
        <span class="c1">#node to graph correspondence dict</span>
        <span class="n">n_to_g_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nodeslab</span><span class="p">,</span> 
                               <span class="p">[</span><span class="n">nn</span><span class="p">[</span><span class="s1">&#39;graph_id&#39;</span><span class="p">]</span> \
                                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_info</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_to_g_dict</span> <span class="o">=</span> <span class="n">n_to_g_dict</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method returning the list of graphs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#this will be the list of graphs to output</span>
        
        <span class="k">for</span> <span class="n">gid</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graphs_id</span><span class="p">):</span>
            
            <span class="n">filt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graphs_id</span> <span class="o">==</span> <span class="n">gid</span> <span class="c1">#selection filter</span>
            
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">filt</span><span class="p">]</span> <span class="c1">#nodes belonging to current graph</span>
            
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feats</span><span class="p">[</span><span class="n">filt</span><span class="p">]</span> <span class="c1">#features belonging to current graph</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">filt</span><span class="p">]</span> <span class="c1">#labels belonging to current graph</span>
            
            <span class="c1">#creating a networkx graph for extracting the adjacency matrix</span>
            <span class="n">g_nx</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
            <span class="n">g_nx</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            
            <span class="n">edges_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">])</span> \
                          <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_info</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">]</span> \
                          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_to_g_dict</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="n">gid</span><span class="p">]</span>
            <span class="n">g_nx</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span>
            
            <span class="n">adj</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">g_nx</span><span class="p">)</span> <span class="c1">#current graph&#39;s adj matrix</span>
            
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">adj</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="n">output</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>After creating the dataset class, I was able to create custom Spektral datasets for all the three phases:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#training</span>
<span class="n">tr_dataset</span> <span class="o">=</span> <span class="n">myCustomDataset</span><span class="p">(</span><span class="n">train_graph</span><span class="p">,</span>
                         <span class="n">train_feats_conc</span><span class="p">,</span>
                         <span class="n">train_labels</span><span class="p">,</span>
                         <span class="n">train_graph_id</span><span class="p">,</span> 
                             <span class="n">transforms</span><span class="o">=</span><span class="p">[</span><span class="n">LayerPreprocess</span><span class="p">(</span><span class="n">GATConv</span><span class="p">)])</span>

<span class="c1">#validation</span>
<span class="n">val_dataset</span> <span class="o">=</span> <span class="n">nPlanDataset</span><span class="p">(</span><span class="n">valid_graph</span><span class="p">,</span>
                         <span class="n">valid_feats_conc</span><span class="p">,</span>
                         <span class="n">valid_labels</span><span class="p">,</span>
                         <span class="n">valid_graph_id</span><span class="p">,</span> 
                           <span class="n">transforms</span><span class="o">=</span><span class="p">[</span><span class="n">LayerPreprocess</span><span class="p">(</span><span class="n">GATConv</span><span class="p">)])</span>

<span class="c1">#testing</span>
<span class="n">te_dataset</span> <span class="o">=</span> <span class="n">nPlanDataset</span><span class="p">(</span><span class="n">test_graph</span><span class="p">,</span>
                         <span class="n">test_feats_conc</span><span class="p">,</span>
                         <span class="n">test_labels</span><span class="p">,</span>
                         <span class="n">test_graph_id</span><span class="p">,</span> 
                          <span class="n">transforms</span><span class="o">=</span><span class="p">[</span><span class="n">LayerPreprocess</span><span class="p">(</span><span class="n">GATConv</span><span class="p">)])</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>Implementing the GAT model</strong></h2> <a class="anchor" id="gat"></a></p>
<p>The model's architecture has been built using the <a href="https://graphneural.network/layers/convolution/#gatconv" target="_blank">Spektral implementation of GAT convolutional layers</a>. As mentioned, I tried to recreate the inductive approach and the model's settings implemented in <a href="https://arxiv.org/pdf/1710.10903.pdf" target="_blank"><em>Graph Attention Networks</em></a><a href="#fn3"><sup>3</sup></a>; below you can see a summary of my final choices:</p>
<ul>
<li>2 GAT layers with 4 attention heads computing 128 features (the original paper states actually 256 features) followed by ELU non-linearity</li>
<li>1 final GAT layer with 6 attention heads which computes the multi-label classification output consisting of a 121 long vector.</li>
<li>Only the intermediate layer has been provided with a dropout value to perform the skip-connection regularization</li>
<li>I used a batch size of 2 graphs</li>
<li>I used <a href="https://keras.io/api/optimizers/adam/" target="_blank">Adam optimizer</a> with a learning rate of 0.005, optimizing on binary cross-entropy and setting up an <a href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/EarlyStopping" target="_blank">`EarlyStopping` stopping callback</a> based on <a href="https://en.wikipedia.org/wiki/F-score" target="_blank">F1 score</a> with micro-averaging, calculated on the validation set.</li>
</ul>
<p>Here's the function used to create the model's architecture to train.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[28]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">create_GAT</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a Graph Attention Network (GAT)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">###############</span>
    <span class="c1"># Parameters</span>
    <span class="c1">###############</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># no. of channels in each head of the first GAT layer</span>
    <span class="n">n_attn_heads</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># no. of att. heads in first and second GAT layer</span>
    <span class="n">n_attn_heads_final</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1"># no. of att. heads in output GAT layer</span>
    <span class="n">mid_layer_skip</span> <span class="o">=</span> <span class="mf">0.6</span>  <span class="c1"># skip connection dropout for middle GAT layer</span>
    <span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">5e-3</span>  <span class="c1"># Learning rate</span>
    
    <span class="c1">#############</span>
    <span class="c1">#Optimizer</span>
    <span class="c1">#############</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span><span class="p">)</span>
    
    <span class="c1">###############</span>
    <span class="c1">#Architecture</span>
    <span class="c1">###############</span>
    
    <span class="c1">#Inputs</span>
    <span class="n">x_in</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">tr_dataset</span><span class="o">.</span><span class="n">n_node_features</span><span class="p">,),</span> 
                 <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;node_features_input&#39;</span><span class="p">)</span>
    
    <span class="n">a_in</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                 <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;adj_input&#39;</span><span class="p">)</span>
    
    <span class="n">i_in</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(),</span> 
                 <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dummy_idx_input&#39;</span><span class="p">)</span> <span class="c1">#dummy input for graph index</span>

    <span class="c1">#GAT layer 1</span>
    <span class="n">gc_1</span> <span class="o">=</span> <span class="n">GATConv</span><span class="p">(</span>
        <span class="n">channels</span><span class="p">,</span>
        <span class="n">attn_heads</span><span class="o">=</span><span class="n">n_attn_heads</span><span class="p">,</span>
        <span class="n">add_self_loops</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#self-loops are already in the dataset</span>
        <span class="n">concat_heads</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">dropout_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;elu&quot;</span><span class="p">,</span>
        <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;glorot_uniform&#39;</span><span class="p">,</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;GAT_1&#39;</span>
    <span class="p">)([</span><span class="n">x_in</span><span class="p">,</span> <span class="n">a_in</span><span class="p">])</span>
    
    <span class="c1">#GAT layer 2</span>
    <span class="n">gc_2</span> <span class="o">=</span> <span class="n">GATConv</span><span class="p">(</span>
        <span class="n">channels</span><span class="p">,</span>
        <span class="n">attn_heads</span> <span class="o">=</span> <span class="n">n_attn_heads</span><span class="p">,</span>
        <span class="n">add_self_loops</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#self-loops are already in the dataset</span>
        <span class="n">concat_heads</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dropout_rate</span> <span class="o">=</span> <span class="n">mid_layer_skip</span><span class="p">,</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="s2">&quot;elu&quot;</span><span class="p">,</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;GAT_2&#39;</span>
    <span class="p">)([</span><span class="n">gc_1</span><span class="p">,</span> <span class="n">a_in</span><span class="p">])</span>
    
    <span class="c1">#GAT layer 3 - output</span>
    <span class="n">gc_3</span> <span class="o">=</span> <span class="n">GATConv</span><span class="p">(</span>
        <span class="n">train_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="c1">#this is the output layer</span>
        <span class="n">attn_heads</span><span class="o">=</span><span class="n">n_attn_heads_final</span><span class="p">,</span>
        <span class="n">add_self_loops</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#self-loops are already in the dataset</span>
        <span class="n">concat_heads</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dropout_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">activation</span><span class="o">=</span> <span class="s2">&quot;sigmoid&quot;</span><span class="p">,</span> <span class="c1"># &quot;softmax&quot;,</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;GAT_final&#39;</span>
    <span class="p">)([</span><span class="n">gc_2</span><span class="p">,</span> <span class="n">a_in</span><span class="p">])</span>
    
   <span class="c1">#############</span>
    <span class="c1">#Compiler</span>
    <span class="c1">############</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">x_in</span><span class="p">,</span> <span class="n">a_in</span><span class="p">,</span> <span class="n">i_in</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="n">gc_3</span><span class="p">)</span>
    
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
        <span class="n">loss</span><span class="o">=</span> <span class="n">BinaryCrossentropy</span><span class="p">(),</span>
        <span class="n">weighted_metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;acc&quot;</span><span class="p">,</span> <span class="n">F1Score</span><span class="p">(</span><span class="n">num_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
                                         <span class="n">average</span> <span class="o">=</span> <span class="s1">&#39;micro&#39;</span><span class="p">,</span> 
                                         <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)],</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">model</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We just need to call the function assigning the model object returned to a variable:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[29]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Build model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">create_GAT</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Model: &#34;model&#34;
__________________________________________________________________________________________________
 Layer (type)                   Output Shape         Param #     Connected to                     
==================================================================================================
 node_features_input (InputLaye  [(None, 65)]        0           []                               
 r)                                                                                               
                                                                                                  
 adj_input (InputLayer)         [(None, None)]       0           []                               
                                                                                                  
 GAT_1 (GATConv)                (None, 512)          34816       [&#39;node_features_input[0][0]&#39;,    
                                                                  &#39;adj_input[0][0]&#39;]              
                                                                                                  
 GAT_2 (GATConv)                (None, 512)          263680      [&#39;GAT_1[0][0]&#39;,                  
                                                                  &#39;adj_input[0][0]&#39;]              
                                                                                                  
 dummy_idx_input (InputLayer)   [(None,)]            0           []                               
                                                                                                  
 GAT_final (GATConv)            (None, 121)          373285      [&#39;GAT_2[0][0]&#39;,                  
                                                                  &#39;adj_input[0][0]&#39;]              
                                                                                                  
==================================================================================================
Total params: 671,781
Trainable params: 671,781
Non-trainable params: 0
__________________________________________________________________________________________________
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>Training and evaluating the model</strong></h2> <a class="anchor" id="train"></a></p>
<p>To feed the model with the data, we need to use the <a href="https://graphneural.network/loaders/" target="_blank">`spektral.data.Loaders`</a>, that iterate over a dataset yielding batches of graphs for training the model.<br>
Having used the <em>disjoint mode</em>, it was pretty obvious to use the <a href="https://graphneural.network/loaders/#disjointloader" target="_blank">`DisjointLoader`</a> as shown below:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[30]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#Loading train, valid and test datasets into Spektral disjoint loaders</span>
<span class="n">tr_loader</span> <span class="o">=</span> <span class="n">DisjointLoader</span><span class="p">(</span><span class="n">tr_dataset</span><span class="p">,</span> 
                           <span class="n">node_level</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">val_loader</span> <span class="o">=</span> <span class="n">DisjointLoader</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">,</span> 
                            <span class="n">node_level</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">te_loader</span> <span class="o">=</span> <span class="n">DisjointLoader</span><span class="p">(</span><span class="n">te_dataset</span><span class="p">,</span> 
                           <span class="n">node_level</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Running the training is pretty much standard tensorflow <code>fit</code> procedure, being careful in specifying batch steps in a way that allows tensorflow to separate graphs from each other:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">set_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="n">epochs</span> <span class="o">=</span> <span class="mi">10000</span>  <span class="c1"># Number of training epochs</span>
<span class="n">patience</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Patience for early stopping</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<span class="c1"># Train model</span>
<span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tr_loader</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>
          <span class="n">steps_per_epoch</span><span class="o">=</span><span class="n">tr_loader</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">,</span>
          <span class="n">validation_data</span> <span class="o">=</span> <span class="n">val_loader</span><span class="o">.</span><span class="n">load</span><span class="p">(),</span>
          <span class="n">validation_steps</span> <span class="o">=</span> <span class="n">val_loader</span><span class="o">.</span><span class="n">steps_per_epoch</span><span class="p">,</span>
         <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
         <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">EarlyStopping</span><span class="p">(</span><span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> 
                                  <span class="n">restore_best_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                  <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> 
                                  <span class="n">monitor</span> <span class="o">=</span> <span class="s1">&#39;val_f1_score&#39;</span><span class="p">)]</span>
<span class="p">)</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">resetwarnings</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Comparing training and validation loss and f1 score, we can see that the model manages to learn quite nicely.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[32]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;loss&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;train loss&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;val_loss&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;valid loss&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;loss&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;f1_score&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;train f1_score&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;val_f1_score&#39;</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;valid_f1_score&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;f1_score&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[32]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>&lt;matplotlib.legend.Legend at 0x18e4ed6cf70&gt;</pre>
</div>

</div>

<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>After being saved, the model has been tested on the provided test set using the code snippet below, and achieving an F1 score of 0.88, which is close to what observed during training and validation.<br>
I hope this article was useful, I personally enjoyed this task very much as it allowed me to do some applied work on graph neural networks.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><h2><strong>References</strong></h2> <a class="anchor" id="references"></a></p>
<p id="fn1">[1] Grattarola D., Alippi C., <a href="https://arxiv.org/pdf/2006.12138.pdf">Graph Neural Networks in TensorFlow and Keras with Spektral</a>, 2020.</p>
<p id="fn2">[2] Zitnik & Leskovec, 2017, et al., <a href="https://distill.pub/2021/gnn-intro/">Predicting multicellular function through multi-layer tissue networks</a>, Bioinformatics 2017, 33 (14): i190-i198.</p>
<p id="fn3">[3] Veličković P., et al., <a href="https://arxiv.org/pdf/1710.10903.pdf">Graph Attention Networks</a>, 2018.</p>
<p id="fn4">[4] Hamilton W. L., Ying R., Leskovec Y., <a href="https://arxiv.org/pdf/1706.02216.pdf">Inductive Representation Learning on Large Graphs</a>, 2017.</p>
</div>
</div>
</div>
 

